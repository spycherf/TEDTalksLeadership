import csv
import os
import re
import sys

from youtube_transcript_api import YouTubeTranscriptApi
from youtube_transcript_api._errors import NoTranscriptAvailable
from youtube_transcript_api._errors import NoTranscriptFound
from youtube_transcript_api._errors import TranscriptsDisabled
from youtube_transcript_api._errors import VideoUnavailable


def get_transcript(yt_id):
    print("Requesting:", yt_id)
    autogenerated = 0
    translated = 0
    src_lang = ""
    transcript = ""

    en_transcript = ""
    available_transcripts = YouTubeTranscriptApi.list_transcripts(yt_id)

    try:
        en_transcript = available_transcripts.find_transcript(["en"])
        if en_transcript.is_generated:
            autogenerated = 1
        src_lang = "en"
        en_transcript = en_transcript.fetch()

    except NoTranscriptFound:
        for k in available_transcripts:
            first_available = k
            break

        if first_available.is_translatable:
            if first_available.is_generated:
                autogenerated = 1
            en_transcript = first_available.translate("en").fetch()
            translated = 1
            src_lang = first_available.language_code

    for caption in en_transcript:
        transcript += (re.sub("\s+", " ", caption["text"].strip() + " "))

    return {"yt_id": yt_id,
            "autogenerated": autogenerated,
            "translated": translated,
            "src_lang": src_lang,
            "transcript": transcript}


def query_and_update(input_file,
                     output_file,
                     success_log,
                     failure_log):

    # Get list of IDs
    with open(input_file, "r") as f:
        ids = [line.strip("\n") for line in f]

    # Get list of IDs that have already been queried and can be skipped
    with open(success_log, "r") as f:
        success = [line.strip("\n") for line in f]
    with open(failure_log, "r") as f:
        failure = [line.strip("\n") for line in f]
    to_skip = success + failure

    csv_header = ["yt_id", "autogenerated", "translated", "src_lang", "transcript"]

    # If output file doesn't exist, write header
    if not os.path.isfile(output_file):
        with open(output_file, "w", newline="", encoding="utf-8") as csv_file:
            writer = csv.DictWriter(csv_file, fieldnames=csv_header)
            writer.writeheader()

    # Get records
    with open(output_file, "a", newline="", encoding="utf-8") as csv_file:
        writer = csv.DictWriter(csv_file, fieldnames=csv_header)

        for video_id in ids:
            sys.stdout.flush()

            if video_id in to_skip:
                continue

            try:
                writer.writerow(get_transcript(video_id))
                csv_file.flush()
                with open(success_log, "a") as f:
                    f.write(video_id + "\n")
            except (VideoUnavailable, NoTranscriptAvailable, TranscriptsDisabled) as e:
                print(e.CAUSE_MESSAGE)
                with open(failure_log, "a") as f:
                    f.write(video_id + "\n")


def main():
    query_and_update("input/youtube_ids.txt",
                     "output/ted_talks_YT_transcripts.csv",
                     "logs/transcripts_successful.txt",
                     "logs/transcripts_failed.txt")


if __name__ == "__main__":
    main()
